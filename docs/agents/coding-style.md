# Coding Style & Naming Conventions

- Formatting and linting are handled by Biome (`biome.json`).
- Indentation is 2 spaces; quotes are double in JS/TS.
- React components use PascalCase (e.g., `GameBoard.tsx`).
- Hooks use `use*` naming (e.g., `useGameState.ts`).
- Prefer arrow functions for components, hooks, utils, and most other functions.
- For route files, function declarations are allowed; if using arrow functions, define them before the `export const Route` to avoid runtime issues.
- Prefer absolute imports with `@/` when possible.
- Relative imports are allowed inside `src/ui/web/components/**` when importing sibling or nested child components (use `./` or `../` only).
- Prefer direct React type/value imports (e.g., `import type { ComponentPropsWithoutRef } from "react"`) over `import * as React`.
- Use typography components for text; add new typography variants only when reused multiple times, otherwise use the closest typography component and override via `className`.
- When adding Tailwind color classes, use the custom theme tokens from `src/ui/web/styles/globals.css` (e.g., `bg-background`, `text-foreground`, `bg-primary`, `text-muted-foreground`) instead of hard-coded colors.
- For conditional class names with `cn`, put shared base classes in the first string argument and use the object form for conditionals instead of ternaries (e.g., `cn("base classes", { "conditional": condition })`).
- When conditionally rendering UI blocks, prefer the `Activity` component with `mode="visible"` or `mode="hidden"` over inline ternary rendering where possible.
- Avoid nested ternaries. A single-level ternary is acceptable, but prefer clearer logic (e.g., `if` blocks or variables) for more complex cases.
- Keep architecture boundaries: repositories live in infrastructure, use cases in application, UI hooks in `src/ui/web/hooks`.
- Use case files and exports must end with `UseCase`.
- Keep reactive Convex queries in UI hooks; repositories should focus on mutations.
- Always run `bun run lint` (Biome) after editing, creating, or generating files to keep formatting consistent.
- Define domain ports as `interface` declarations so implementations are discoverable in IDEs.
